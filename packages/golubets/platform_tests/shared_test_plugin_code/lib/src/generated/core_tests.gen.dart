// Copyright 2013 The Flutter Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Golubets, do not edit directly.
// See also: https://pub.dev/packages/golubets
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse({
  Object? result,
  PlatformException? error,
  bool empty = false,
}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

bool _deepEquals(Object? a, Object? b) {
  if (a is List && b is List) {
    return a.length == b.length &&
        a.indexed.every(
          ((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]),
        );
  }
  if (a is Map && b is Map) {
    return a.length == b.length &&
        a.entries.every(
          (MapEntry<Object?, Object?> entry) =>
              (b as Map<Object?, Object?>).containsKey(entry.key) &&
              _deepEquals(entry.value, b[entry.key]),
        );
  }
  return a == b;
}

enum AnEnum {
  one,
  two,
  three,
  fortyTwo,
  fourHundredTwentyTwo,
}

enum AnotherEnum {
  justInCase,
}

class UnusedClass {
  UnusedClass({
    this.aField,
  });

  Object? aField;

  List<Object?> _toList() {
    return <Object?>[
      aField,
    ];
  }

  Object encode() {
    return _toList();
  }

  static UnusedClass decode(Object result) {
    result as List<Object?>;
    return UnusedClass(
      aField: result[0],
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! UnusedClass || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// A class containing all supported types.
class AllTypes {
  AllTypes({
    this.aBool = false,
    this.anInt = 0,
    this.anInt64 = 0,
    this.aDouble = 0,
    required this.aByteArray,
    required this.a4ByteArray,
    required this.a8ByteArray,
    required this.aFloatArray,
    this.anEnum = AnEnum.one,
    this.anotherEnum = AnotherEnum.justInCase,
    this.aString = '',
    this.anObject = 0,
    required this.list,
    required this.stringList,
    required this.intList,
    required this.doubleList,
    required this.boolList,
    required this.enumList,
    required this.objectList,
    required this.listList,
    required this.mapList,
    required this.map,
    required this.stringMap,
    required this.intMap,
    required this.enumMap,
    required this.objectMap,
    required this.listMap,
    required this.mapMap,
  });

  bool aBool;

  int anInt;

  int anInt64;

  double aDouble;

  Uint8List aByteArray;

  Int32List a4ByteArray;

  Int64List a8ByteArray;

  Float64List aFloatArray;

  AnEnum anEnum;

  AnotherEnum anotherEnum;

  String aString;

  Object anObject;

  List<Object?> list;

  List<String> stringList;

  List<int> intList;

  List<double> doubleList;

  List<bool> boolList;

  List<AnEnum> enumList;

  List<Object> objectList;

  List<List<Object?>> listList;

  List<Map<Object?, Object?>> mapList;

  Map<Object?, Object?> map;

  Map<String, String> stringMap;

  Map<int, int> intMap;

  Map<AnEnum, AnEnum> enumMap;

  Map<Object, Object> objectMap;

  Map<int, List<Object?>> listMap;

  Map<int, Map<Object?, Object?>> mapMap;

  List<Object?> _toList() {
    return <Object?>[
      aBool,
      anInt,
      anInt64,
      aDouble,
      aByteArray,
      a4ByteArray,
      a8ByteArray,
      aFloatArray,
      anEnum,
      anotherEnum,
      aString,
      anObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
    ];
  }

  Object encode() {
    return _toList();
  }

  static AllTypes decode(Object result) {
    result as List<Object?>;
    return AllTypes(
      aBool: result[0]! as bool,
      anInt: result[1]! as int,
      anInt64: result[2]! as int,
      aDouble: result[3]! as double,
      aByteArray: result[4]! as Uint8List,
      a4ByteArray: result[5]! as Int32List,
      a8ByteArray: result[6]! as Int64List,
      aFloatArray: result[7]! as Float64List,
      anEnum: result[8]! as AnEnum,
      anotherEnum: result[9]! as AnotherEnum,
      aString: result[10]! as String,
      anObject: result[11]!,
      list: result[12]! as List<Object?>,
      stringList: (result[13] as List<Object?>?)!.cast<String>(),
      intList: (result[14] as List<Object?>?)!.cast<int>(),
      doubleList: (result[15] as List<Object?>?)!.cast<double>(),
      boolList: (result[16] as List<Object?>?)!.cast<bool>(),
      enumList: (result[17] as List<Object?>?)!.cast<AnEnum>(),
      objectList: (result[18] as List<Object?>?)!.cast<Object>(),
      listList: (result[19] as List<Object?>?)!.cast<List<Object?>>(),
      mapList: (result[20] as List<Object?>?)!.cast<Map<Object?, Object?>>(),
      map: result[21]! as Map<Object?, Object?>,
      stringMap: (result[22] as Map<Object?, Object?>?)!.cast<String, String>(),
      intMap: (result[23] as Map<Object?, Object?>?)!.cast<int, int>(),
      enumMap: (result[24] as Map<Object?, Object?>?)!.cast<AnEnum, AnEnum>(),
      objectMap: (result[25] as Map<Object?, Object?>?)!.cast<Object, Object>(),
      listMap: (result[26] as Map<Object?, Object?>?)!
          .cast<int, List<Object?>>(),
      mapMap: (result[27] as Map<Object?, Object?>?)!
          .cast<int, Map<Object?, Object?>>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AllTypes || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// A class containing all supported nullable types.
class AllNullableTypes {
  AllNullableTypes({
    this.aNullableBool,
    this.aNullableInt,
    this.aNullableInt64,
    this.aNullableDouble,
    this.aNullableByteArray,
    this.aNullable4ByteArray,
    this.aNullable8ByteArray,
    this.aNullableFloatArray,
    this.aNullableEnum,
    this.anotherNullableEnum,
    this.aNullableString,
    this.aNullableObject,
    this.allNullableTypes,
    this.list,
    this.stringList,
    this.intList,
    this.doubleList,
    this.boolList,
    this.enumList,
    this.objectList,
    this.listList,
    this.mapList,
    this.recursiveClassList,
    this.map,
    this.stringMap,
    this.intMap,
    this.enumMap,
    this.objectMap,
    this.listMap,
    this.mapMap,
    this.recursiveClassMap,
  });

  bool? aNullableBool;

  int? aNullableInt;

  int? aNullableInt64;

  double? aNullableDouble;

  Uint8List? aNullableByteArray;

  Int32List? aNullable4ByteArray;

  Int64List? aNullable8ByteArray;

  Float64List? aNullableFloatArray;

  AnEnum? aNullableEnum;

  AnotherEnum? anotherNullableEnum;

  String? aNullableString;

  Object? aNullableObject;

  AllNullableTypes? allNullableTypes;

  List<Object?>? list;

  List<String?>? stringList;

  List<int?>? intList;

  List<double?>? doubleList;

  List<bool?>? boolList;

  List<AnEnum?>? enumList;

  List<Object?>? objectList;

  List<List<Object?>?>? listList;

  List<Map<Object?, Object?>?>? mapList;

  List<AllNullableTypes?>? recursiveClassList;

  Map<Object?, Object?>? map;

  Map<String?, String?>? stringMap;

  Map<int?, int?>? intMap;

  Map<AnEnum?, AnEnum?>? enumMap;

  Map<Object?, Object?>? objectMap;

  Map<int?, List<Object?>?>? listMap;

  Map<int?, Map<Object?, Object?>?>? mapMap;

  Map<int?, AllNullableTypes?>? recursiveClassMap;

  List<Object?> _toList() {
    return <Object?>[
      aNullableBool,
      aNullableInt,
      aNullableInt64,
      aNullableDouble,
      aNullableByteArray,
      aNullable4ByteArray,
      aNullable8ByteArray,
      aNullableFloatArray,
      aNullableEnum,
      anotherNullableEnum,
      aNullableString,
      aNullableObject,
      allNullableTypes,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      recursiveClassList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
      recursiveClassMap,
    ];
  }

  Object encode() {
    return _toList();
  }

  static AllNullableTypes decode(Object result) {
    result as List<Object?>;
    return AllNullableTypes(
      aNullableBool: result[0] as bool?,
      aNullableInt: result[1] as int?,
      aNullableInt64: result[2] as int?,
      aNullableDouble: result[3] as double?,
      aNullableByteArray: result[4] as Uint8List?,
      aNullable4ByteArray: result[5] as Int32List?,
      aNullable8ByteArray: result[6] as Int64List?,
      aNullableFloatArray: result[7] as Float64List?,
      aNullableEnum: result[8] as AnEnum?,
      anotherNullableEnum: result[9] as AnotherEnum?,
      aNullableString: result[10] as String?,
      aNullableObject: result[11],
      allNullableTypes: result[12] as AllNullableTypes?,
      list: result[13] as List<Object?>?,
      stringList: (result[14] as List<Object?>?)?.cast<String?>(),
      intList: (result[15] as List<Object?>?)?.cast<int?>(),
      doubleList: (result[16] as List<Object?>?)?.cast<double?>(),
      boolList: (result[17] as List<Object?>?)?.cast<bool?>(),
      enumList: (result[18] as List<Object?>?)?.cast<AnEnum?>(),
      objectList: (result[19] as List<Object?>?)?.cast<Object?>(),
      listList: (result[20] as List<Object?>?)?.cast<List<Object?>?>(),
      mapList: (result[21] as List<Object?>?)?.cast<Map<Object?, Object?>?>(),
      recursiveClassList: (result[22] as List<Object?>?)
          ?.cast<AllNullableTypes?>(),
      map: result[23] as Map<Object?, Object?>?,
      stringMap: (result[24] as Map<Object?, Object?>?)
          ?.cast<String?, String?>(),
      intMap: (result[25] as Map<Object?, Object?>?)?.cast<int?, int?>(),
      enumMap: (result[26] as Map<Object?, Object?>?)?.cast<AnEnum?, AnEnum?>(),
      objectMap: (result[27] as Map<Object?, Object?>?)
          ?.cast<Object?, Object?>(),
      listMap: (result[28] as Map<Object?, Object?>?)
          ?.cast<int?, List<Object?>?>(),
      mapMap: (result[29] as Map<Object?, Object?>?)
          ?.cast<int?, Map<Object?, Object?>?>(),
      recursiveClassMap: (result[30] as Map<Object?, Object?>?)
          ?.cast<int?, AllNullableTypes?>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AllNullableTypes || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// The primary purpose for this class is to ensure coverage of Swift structs
/// with nullable items, as the primary [AllNullableTypes] class is being used to
/// test Swift classes.
class AllNullableTypesWithoutRecursion {
  AllNullableTypesWithoutRecursion({
    this.aNullableBool,
    this.aNullableInt,
    this.aNullableInt64,
    this.aNullableDouble,
    this.aNullableByteArray,
    this.aNullable4ByteArray,
    this.aNullable8ByteArray,
    this.aNullableFloatArray,
    this.aNullableEnum,
    this.anotherNullableEnum,
    this.aNullableString,
    this.aNullableObject,
    this.list,
    this.stringList,
    this.intList,
    this.doubleList,
    this.boolList,
    this.enumList,
    this.objectList,
    this.listList,
    this.mapList,
    this.map,
    this.stringMap,
    this.intMap,
    this.enumMap,
    this.objectMap,
    this.listMap,
    this.mapMap,
  });

  bool? aNullableBool;

  int? aNullableInt;

  int? aNullableInt64;

  double? aNullableDouble;

  Uint8List? aNullableByteArray;

  Int32List? aNullable4ByteArray;

  Int64List? aNullable8ByteArray;

  Float64List? aNullableFloatArray;

  AnEnum? aNullableEnum;

  AnotherEnum? anotherNullableEnum;

  String? aNullableString;

  Object? aNullableObject;

  List<Object?>? list;

  List<String?>? stringList;

  List<int?>? intList;

  List<double?>? doubleList;

  List<bool?>? boolList;

  List<AnEnum?>? enumList;

  List<Object?>? objectList;

  List<List<Object?>?>? listList;

  List<Map<Object?, Object?>?>? mapList;

  Map<Object?, Object?>? map;

  Map<String?, String?>? stringMap;

  Map<int?, int?>? intMap;

  Map<AnEnum?, AnEnum?>? enumMap;

  Map<Object?, Object?>? objectMap;

  Map<int?, List<Object?>?>? listMap;

  Map<int?, Map<Object?, Object?>?>? mapMap;

  List<Object?> _toList() {
    return <Object?>[
      aNullableBool,
      aNullableInt,
      aNullableInt64,
      aNullableDouble,
      aNullableByteArray,
      aNullable4ByteArray,
      aNullable8ByteArray,
      aNullableFloatArray,
      aNullableEnum,
      anotherNullableEnum,
      aNullableString,
      aNullableObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
    ];
  }

  Object encode() {
    return _toList();
  }

  static AllNullableTypesWithoutRecursion decode(Object result) {
    result as List<Object?>;
    return AllNullableTypesWithoutRecursion(
      aNullableBool: result[0] as bool?,
      aNullableInt: result[1] as int?,
      aNullableInt64: result[2] as int?,
      aNullableDouble: result[3] as double?,
      aNullableByteArray: result[4] as Uint8List?,
      aNullable4ByteArray: result[5] as Int32List?,
      aNullable8ByteArray: result[6] as Int64List?,
      aNullableFloatArray: result[7] as Float64List?,
      aNullableEnum: result[8] as AnEnum?,
      anotherNullableEnum: result[9] as AnotherEnum?,
      aNullableString: result[10] as String?,
      aNullableObject: result[11],
      list: result[12] as List<Object?>?,
      stringList: (result[13] as List<Object?>?)?.cast<String?>(),
      intList: (result[14] as List<Object?>?)?.cast<int?>(),
      doubleList: (result[15] as List<Object?>?)?.cast<double?>(),
      boolList: (result[16] as List<Object?>?)?.cast<bool?>(),
      enumList: (result[17] as List<Object?>?)?.cast<AnEnum?>(),
      objectList: (result[18] as List<Object?>?)?.cast<Object?>(),
      listList: (result[19] as List<Object?>?)?.cast<List<Object?>?>(),
      mapList: (result[20] as List<Object?>?)?.cast<Map<Object?, Object?>?>(),
      map: result[21] as Map<Object?, Object?>?,
      stringMap: (result[22] as Map<Object?, Object?>?)
          ?.cast<String?, String?>(),
      intMap: (result[23] as Map<Object?, Object?>?)?.cast<int?, int?>(),
      enumMap: (result[24] as Map<Object?, Object?>?)?.cast<AnEnum?, AnEnum?>(),
      objectMap: (result[25] as Map<Object?, Object?>?)
          ?.cast<Object?, Object?>(),
      listMap: (result[26] as Map<Object?, Object?>?)
          ?.cast<int?, List<Object?>?>(),
      mapMap: (result[27] as Map<Object?, Object?>?)
          ?.cast<int?, Map<Object?, Object?>?>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AllNullableTypesWithoutRecursion ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// A class for testing nested class handling.
///
/// This is needed to test nested nullable and non-nullable classes,
/// `AllNullableTypes` is non-nullable here as it is easier to instantiate
/// than `AllTypes` when testing doesn't require both (ie. testing null classes).
class AllClassesWrapper {
  AllClassesWrapper({
    required this.allNullableTypes,
    this.allNullableTypesWithoutRecursion,
    this.allTypes,
    required this.classList,
    this.nullableClassList,
    required this.classMap,
    this.nullableClassMap,
  });

  AllNullableTypes allNullableTypes;

  AllNullableTypesWithoutRecursion? allNullableTypesWithoutRecursion;

  AllTypes? allTypes;

  List<AllTypes?> classList;

  List<AllNullableTypesWithoutRecursion?>? nullableClassList;

  Map<int?, AllTypes?> classMap;

  Map<int?, AllNullableTypesWithoutRecursion?>? nullableClassMap;

  List<Object?> _toList() {
    return <Object?>[
      allNullableTypes,
      allNullableTypesWithoutRecursion,
      allTypes,
      classList,
      nullableClassList,
      classMap,
      nullableClassMap,
    ];
  }

  Object encode() {
    return _toList();
  }

  static AllClassesWrapper decode(Object result) {
    result as List<Object?>;
    return AllClassesWrapper(
      allNullableTypes: result[0]! as AllNullableTypes,
      allNullableTypesWithoutRecursion:
          result[1] as AllNullableTypesWithoutRecursion?,
      allTypes: result[2] as AllTypes?,
      classList: (result[3] as List<Object?>?)!.cast<AllTypes?>(),
      nullableClassList: (result[4] as List<Object?>?)
          ?.cast<AllNullableTypesWithoutRecursion?>(),
      classMap: (result[5] as Map<Object?, Object?>?)!.cast<int?, AllTypes?>(),
      nullableClassMap: (result[6] as Map<Object?, Object?>?)
          ?.cast<int?, AllNullableTypesWithoutRecursion?>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AllClassesWrapper || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// A class containing all supported types but immutable.
class ImmutableAllTypes {
  const ImmutableAllTypes({
    required this.aBool,
    required this.anInt,
    required this.anInt64,
    required this.aDouble,
    required this.anEnum,
    required this.anotherEnum,
    required this.aString,
    required this.anObject,
    required this.list,
    required this.stringList,
    required this.intList,
    required this.doubleList,
    required this.boolList,
    required this.enumList,
    required this.objectList,
    required this.listList,
    required this.mapList,
    required this.map,
    required this.stringMap,
    required this.intMap,
    required this.enumMap,
    required this.objectMap,
    required this.listMap,
    required this.mapMap,
  });

  final bool aBool;

  final int anInt;

  final int anInt64;

  final double aDouble;

  final AnEnum anEnum;

  final AnotherEnum anotherEnum;

  final String aString;

  final Object anObject;

  final List<Object?> list;

  final List<String> stringList;

  final List<int> intList;

  final List<double> doubleList;

  final List<bool> boolList;

  final List<AnEnum> enumList;

  final List<Object> objectList;

  final List<List<Object?>> listList;

  final List<Map<Object?, Object?>> mapList;

  final Map<Object?, Object?> map;

  final Map<String, String> stringMap;

  final Map<int, int> intMap;

  final Map<AnEnum, AnEnum> enumMap;

  final Map<Object, Object> objectMap;

  final Map<int, List<Object?>> listMap;

  final Map<int, Map<Object?, Object?>> mapMap;

  List<Object?> _toList() {
    return <Object?>[
      aBool,
      anInt,
      anInt64,
      aDouble,
      anEnum,
      anotherEnum,
      aString,
      anObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
    ];
  }

  Object encode() {
    return _toList();
  }

  static ImmutableAllTypes decode(Object result) {
    result as List<Object?>;
    return ImmutableAllTypes(
      aBool: result[0]! as bool,
      anInt: result[1]! as int,
      anInt64: result[2]! as int,
      aDouble: result[3]! as double,
      anEnum: result[4]! as AnEnum,
      anotherEnum: result[5]! as AnotherEnum,
      aString: result[6]! as String,
      anObject: result[7]!,
      list: result[8]! as List<Object?>,
      stringList: (result[9] as List<Object?>?)!.cast<String>(),
      intList: (result[10] as List<Object?>?)!.cast<int>(),
      doubleList: (result[11] as List<Object?>?)!.cast<double>(),
      boolList: (result[12] as List<Object?>?)!.cast<bool>(),
      enumList: (result[13] as List<Object?>?)!.cast<AnEnum>(),
      objectList: (result[14] as List<Object?>?)!.cast<Object>(),
      listList: (result[15] as List<Object?>?)!.cast<List<Object?>>(),
      mapList: (result[16] as List<Object?>?)!.cast<Map<Object?, Object?>>(),
      map: result[17]! as Map<Object?, Object?>,
      stringMap: (result[18] as Map<Object?, Object?>?)!.cast<String, String>(),
      intMap: (result[19] as Map<Object?, Object?>?)!.cast<int, int>(),
      enumMap: (result[20] as Map<Object?, Object?>?)!.cast<AnEnum, AnEnum>(),
      objectMap: (result[21] as Map<Object?, Object?>?)!.cast<Object, Object>(),
      listMap: (result[22] as Map<Object?, Object?>?)!
          .cast<int, List<Object?>>(),
      mapMap: (result[23] as Map<Object?, Object?>?)!
          .cast<int, Map<Object?, Object?>>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! ImmutableAllTypes || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// A class containing all supported types but with default values.
class AllTypesWithDefaults {
  AllTypesWithDefaults({
    this.aBool = false,
    this.anInt = 0,
    this.anInt64 = 0,
    this.aDouble = 0.0,
    this.anEnum = AnEnum.one,
    this.anotherEnum = AnotherEnum.justInCase,
    this.aString = '',
    this.anObject = 0,
    this.list = const <Object?>[
      1,
      'string',
      3.0,
      true,
      AnEnum.fortyTwo,
      const <Object?>[],
      const <String, String>{
        'hello': 'world',
      },
    ],
    this.stringList = const <String>[
      'hello',
      'world',
    ],
    this.intList = const <int>[
      1,
      2,
      3,
    ],
    this.doubleList = const <double>[
      1.0,
      2.0,
      3.0,
      5,
      10,
      20.0,
      3,
    ],
    this.boolList = const <bool>[
      true,
      false,
      true,
    ],
    this.enumList = const <AnEnum>[
      AnEnum.one,
      AnEnum.two,
      AnEnum.three,
      AnEnum.fortyTwo,
      AnEnum.fourHundredTwentyTwo,
    ],
    this.objectList = const <Object>[
      1,
      'string',
      3.0,
      true,
      AnEnum.fortyTwo,
      const <Object?>[],
      const <String, String>{
        'hello': 'world',
      },
    ],
    this.listList = const <List<Object?>>[
      const <Object?>[
        1,
        2,
        3,
      ],
      const <Object?>[
        'hello',
        'world',
      ],
      const <Object?>[
        true,
        false,
        true,
      ],
      const <Object?>[
        AnEnum.one,
        AnEnum.two,
        AnEnum.three,
      ],
      const <Object?>[
        const <Object?>[],
        const <Object?>[
          1,
          2,
          3,
        ],
      ],
      const <Object?>[
        const <String, String>{
          'hello': 'world',
        },
        const <String, String>{
          'lorem': 'ipsum',
        },
      ],
      const <Object?>[
        const <Object?>[],
        const <Object?>[
          1,
          2,
          3,
        ],
      ],
      const <Object?>[
        const <String, double>{
          'hello': 0.0,
          'world': 1,
        },
      ],
    ],
    this.mapList = const <Map<Object?, Object?>>[
      const <Object?, Object?>{
        1: 'hello',
        2: 'world',
      },
      const <Object?, Object?>{
        'hello': 1,
        'world': 2,
      },
      const <Object?, Object?>{
        AnEnum.one: 'hello',
        AnEnum.two: 'world',
      },
      const <Object?, Object?>{
        'hello': AnEnum.one,
        'world': AnEnum.two,
      },
      const <Object?, Object?>{
        1: const <Object?>[
          1,
          2,
          3,
        ],
        2: const <Object?>[
          'hello',
          'world',
        ],
      },
      const <Object?, Object?>{
        'hello': const <String, String>{
          'hello': 'world',
        },
        'lorem': const <String, String>{
          'lorem': 'ipsum',
        },
      },
      const <Object?, Object?>{
        AnEnum.one: const <String, double>{
          'hello': 0.0,
          'world': 1,
        },
      },
    ],
    this.map = const <Object?, Object?>{
      1: 'hello',
      'world': 2.0,
      AnEnum.one: 'hello',
      'worldEnum': AnEnum.two,
      'list': const <Object?>[
        1,
        2,
        3,
      ],
      'map': const <String, String>{
        'hello': 'world',
      },
      'mapDouble': const <String, double>{
        'hello': 2,
        'world': 3.0,
      },
    },
    this.stringMap = const <String, String>{
      'hello': 'world',
      'lorem': 'ipsum',
      'golub': 'rocks',
    },
    this.intMap = const <int, int>{
      1: 2,
      3: 4,
      5: 6,
    },
    this.enumMap = const <AnEnum, AnEnum>{
      AnEnum.one: AnEnum.two,
      AnEnum.three: AnEnum.fortyTwo,
      AnEnum.fourHundredTwentyTwo: AnEnum.one,
    },
    this.objectMap = const <Object, Object>{
      1: 'hello',
      'world': 2.0,
      AnEnum.one: 'hello',
      'worldEnum': AnEnum.two,
      'list': const <Object?>[
        1,
        2,
        3,
      ],
      'map': const <String, String>{
        'hello': 'world',
      },
      'doubleMap': const <int, double>{
        1: 1.0,
        2: 0.0,
        3: 3.0,
      },
    },
    this.listMap = const <int, List<Object?>>{
      1: const <Object?>[
        1,
        2,
        3,
      ],
      2: const <Object?>[
        'hello',
        'world',
      ],
      3: const <Object?>[
        true,
        false,
        true,
      ],
      4: const <Object?>[
        AnEnum.one,
        AnEnum.two,
        AnEnum.three,
      ],
      5: const <Object?>[
        const <Object?>[],
        const <Object?>[
          1,
          2,
          3,
        ],
      ],
      6: const <Object?>[
        const <String, String>{
          'hello': 'world',
        },
        const <String, String>{
          'lorem': 'ipsum',
        },
      ],
      7: const <Object?>[
        2,
        3.0,
        5,
        10,
        20.0,
        3,
      ],
    },
    this.mapMap = const <int, Map<Object?, Object?>>{
      1: const <Object?, Object?>{
        1: 'hello',
        2: 'world',
      },
      2: const <Object?, Object?>{
        'hello': 1,
        'world': 2,
      },
      3: const <Object?, Object?>{
        AnEnum.one: 'hello',
        AnEnum.two: 'world',
      },
      4: const <Object?, Object?>{
        'hello': AnEnum.one,
        'world': AnEnum.two,
      },
      5: const <Object?, Object?>{
        1: const <Object?>[
          1,
          2,
          3,
        ],
        2: const <Object?>[
          'hello',
          'world',
        ],
      },
      6: const <Object?, Object?>{
        'hello': const <String, String>{
          'hello': 'world',
        },
        'lorem': const <String, String>{
          'lorem': 'ipsum',
        },
      },
      7: const <Object?, Object?>{
        AnEnum.one: const <String, double>{
          'hello': 0.0,
          'world': 1,
        },
      },
    },
    this.allTypes = const ImmutableAllTypes(
      aBool: false,
      anInt: 0,
      anInt64: 0,
      aDouble: 0,
      anEnum: AnEnum.one,
      anotherEnum: AnotherEnum.justInCase,
      aString: 'some string',
      anObject: 0,
      list: const <Object?>[
        1,
        'string',
        3.0,
        true,
        AnEnum.fortyTwo,
        const <Object?>[],
        const <String, String>{
          'hello': 'world',
        },
      ],
      stringList: const <String>[
        'hello',
        'world',
      ],
      intList: const <int>[
        1,
        2,
        3,
      ],
      doubleList: const <double>[
        1.0,
        2.0,
        3.0,
        5,
        10,
        20.0,
        3,
      ],
      boolList: const <bool>[
        true,
        false,
        true,
      ],
      enumList: const <AnEnum>[
        AnEnum.one,
        AnEnum.two,
        AnEnum.three,
        AnEnum.fortyTwo,
        AnEnum.fourHundredTwentyTwo,
      ],
      objectList: const <Object>[
        1,
        'string',
        3.0,
        true,
        AnEnum.fortyTwo,
        const <Object?>[],
        const <String, String>{
          'hello': 'world',
        },
      ],
      listList: const <List<Object?>>[
        const <Object?>[
          1,
          2,
          3,
        ],
        const <Object?>[
          'hello',
          'world',
        ],
        const <Object?>[
          true,
          false,
          true,
        ],
        const <Object?>[
          AnEnum.one,
          AnEnum.two,
          AnEnum.three,
        ],
        const <Object?>[
          const <Object?>[],
          const <Object?>[
            1,
            2,
            3,
          ],
        ],
        const <Object?>[
          const <String, String>{
            'hello': 'world',
          },
          const <String, String>{
            'lorem': 'ipsum',
          },
        ],
        const <Object?>[
          const <Object?>[],
          const <Object?>[
            1,
            2,
            3,
          ],
        ],
        const <Object?>[
          const <String, double>{
            'hello': 0.0,
            'world': 1,
          },
        ],
      ],
      mapList: const <Map<Object?, Object?>>[
        const <Object?, Object?>{
          1: 'hello',
          2: 'world',
        },
        const <Object?, Object?>{
          'hello': 1,
          'world': 2,
        },
        const <Object?, Object?>{
          AnEnum.one: 'hello',
          AnEnum.two: 'world',
        },
        const <Object?, Object?>{
          'hello': AnEnum.one,
          'world': AnEnum.two,
        },
        const <Object?, Object?>{
          1: const <Object?>[
            1,
            2,
            3,
          ],
          2: const <Object?>[
            'hello',
            'world',
          ],
        },
        const <Object?, Object?>{
          'hello': const <String, String>{
            'hello': 'world',
          },
          'lorem': const <String, String>{
            'lorem': 'ipsum',
          },
        },
        const <Object?, Object?>{
          AnEnum.one: const <String, double>{
            'hello': 0.0,
            'world': 1,
          },
        },
      ],
      map: const <Object?, Object?>{
        1: 'hello',
        'world': 2.0,
        AnEnum.one: 'hello',
        'worldEnum': AnEnum.two,
        'list': const <Object?>[
          1,
          2,
          3,
        ],
        'map': const <String, String>{
          'hello': 'world',
        },
        'mapDouble': const <String, double>{
          'hello': 2,
          'world': 3.0,
        },
      },
      stringMap: const <String, String>{
        'hello': 'world',
        'lorem': 'ipsum',
        'golub': 'rocks',
      },
      intMap: const <int, int>{
        1: 2,
        3: 4,
        5: 6,
      },
      enumMap: const <AnEnum, AnEnum>{
        AnEnum.one: AnEnum.two,
        AnEnum.three: AnEnum.fortyTwo,
        AnEnum.fourHundredTwentyTwo: AnEnum.one,
      },
      objectMap: const <Object, Object>{
        1: 'hello',
        'world': 2.0,
        AnEnum.one: 'hello',
        'worldEnum': AnEnum.two,
        'list': const <Object?>[
          1,
          2,
          3,
        ],
        'map': const <String, String>{
          'hello': 'world',
        },
        'doubleMap': const <int, double>{
          1: 1,
          2: 0,
          3: 3.0,
        },
      },
      listMap: const <int, List<Object?>>{
        1: const <Object?>[
          1,
          2,
          3,
        ],
        2: const <Object?>[
          'hello',
          'world',
        ],
        3: const <Object?>[
          true,
          false,
          true,
        ],
        4: const <Object?>[
          AnEnum.one,
          AnEnum.two,
          AnEnum.three,
        ],
        5: const <Object?>[
          const <Object?>[],
          const <Object?>[
            1,
            2,
            3,
          ],
        ],
        6: const <Object?>[
          const <String, String>{
            'hello': 'world',
          },
          const <String, String>{
            'lorem': 'ipsum',
          },
        ],
        7: const <Object?>[
          2,
          3.0,
          5,
          10,
          20.0,
          3,
        ],
      },
      mapMap: const <int, Map<Object?, Object?>>{
        1: const <Object?, Object?>{
          1: 'hello',
          2: 'world',
        },
        2: const <Object?, Object?>{
          'hello': 1,
          'world': 2,
        },
        3: const <Object?, Object?>{
          AnEnum.one: 'hello',
          AnEnum.two: 'world',
        },
        4: const <Object?, Object?>{
          'hello': AnEnum.one,
          'world': AnEnum.two,
        },
        5: const <Object?, Object?>{
          1: const <Object?>[
            1,
            2,
            3,
          ],
          2: const <Object?>[
            'hello',
            'world',
          ],
        },
        6: const <Object?, Object?>{
          'hello': const <String, String>{
            'hello': 'world',
          },
          'lorem': const <String, String>{
            'lorem': 'ipsum',
          },
        },
        7: const <Object?, Object?>{
          AnEnum.one: const <String, double>{
            'hello': 0.0,
            'world': 1,
          },
        },
      },
    ),
  });

  bool aBool;

  int anInt;

  int anInt64;

  double aDouble;

  AnEnum anEnum;

  AnotherEnum anotherEnum;

  String aString;

  Object anObject;

  List<Object?> list;

  List<String> stringList;

  List<int> intList;

  List<double> doubleList;

  List<bool> boolList;

  List<AnEnum> enumList;

  List<Object> objectList;

  List<List<Object?>> listList;

  List<Map<Object?, Object?>> mapList;

  Map<Object?, Object?> map;

  Map<String, String> stringMap;

  Map<int, int> intMap;

  Map<AnEnum, AnEnum> enumMap;

  Map<Object, Object> objectMap;

  Map<int, List<Object?>> listMap;

  Map<int, Map<Object?, Object?>> mapMap;

  ImmutableAllTypes allTypes;

  List<Object?> _toList() {
    return <Object?>[
      aBool,
      anInt,
      anInt64,
      aDouble,
      anEnum,
      anotherEnum,
      aString,
      anObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
      allTypes,
    ];
  }

  Object encode() {
    return _toList();
  }

  static AllTypesWithDefaults decode(Object result) {
    result as List<Object?>;
    return AllTypesWithDefaults(
      aBool: result[0]! as bool,
      anInt: result[1]! as int,
      anInt64: result[2]! as int,
      aDouble: result[3]! as double,
      anEnum: result[4]! as AnEnum,
      anotherEnum: result[5]! as AnotherEnum,
      aString: result[6]! as String,
      anObject: result[7]!,
      list: result[8]! as List<Object?>,
      stringList: (result[9] as List<Object?>?)!.cast<String>(),
      intList: (result[10] as List<Object?>?)!.cast<int>(),
      doubleList: (result[11] as List<Object?>?)!.cast<double>(),
      boolList: (result[12] as List<Object?>?)!.cast<bool>(),
      enumList: (result[13] as List<Object?>?)!.cast<AnEnum>(),
      objectList: (result[14] as List<Object?>?)!.cast<Object>(),
      listList: (result[15] as List<Object?>?)!.cast<List<Object?>>(),
      mapList: (result[16] as List<Object?>?)!.cast<Map<Object?, Object?>>(),
      map: result[17]! as Map<Object?, Object?>,
      stringMap: (result[18] as Map<Object?, Object?>?)!.cast<String, String>(),
      intMap: (result[19] as Map<Object?, Object?>?)!.cast<int, int>(),
      enumMap: (result[20] as Map<Object?, Object?>?)!.cast<AnEnum, AnEnum>(),
      objectMap: (result[21] as Map<Object?, Object?>?)!.cast<Object, Object>(),
      listMap: (result[22] as Map<Object?, Object?>?)!
          .cast<int, List<Object?>>(),
      mapMap: (result[23] as Map<Object?, Object?>?)!
          .cast<int, Map<Object?, Object?>>(),
      allTypes: result[24]! as ImmutableAllTypes,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AllTypesWithDefaults || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// A data class containing a List, used in unit tests.
class TestMessage {
  TestMessage({
    this.testList,
  });

  List<Object?>? testList;

  List<Object?> _toList() {
    return <Object?>[
      testList,
    ];
  }

  Object encode() {
    return _toList();
  }

  static TestMessage decode(Object result) {
    result as List<Object?>;
    return TestMessage(
      testList: result[0] as List<Object?>?,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! TestMessage || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

class _GolubetsCodec extends StandardMessageCodec {
  const _GolubetsCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is AnEnum) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is AnotherEnum) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    } else if (value is UnusedClass) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is AllTypes) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is AllNullableTypes) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is AllNullableTypesWithoutRecursion) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is AllClassesWrapper) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is ImmutableAllTypes) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is AllTypesWithDefaults) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is TestMessage) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnEnum.values[value];
      case 130:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnotherEnum.values[value];
      case 131:
        return UnusedClass.decode(readValue(buffer)!);
      case 132:
        return AllTypes.decode(readValue(buffer)!);
      case 133:
        return AllNullableTypes.decode(readValue(buffer)!);
      case 134:
        return AllNullableTypesWithoutRecursion.decode(readValue(buffer)!);
      case 135:
        return AllClassesWrapper.decode(readValue(buffer)!);
      case 136:
        return ImmutableAllTypes.decode(readValue(buffer)!);
      case 137:
        return AllTypesWithDefaults.decode(readValue(buffer)!);
      case 138:
        return TestMessage.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// The core interface that each host language plugin must implement in
/// platform_test integration tests.
class HostIntegrationCoreApi {
  /// Constructor for [HostIntegrationCoreApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  HostIntegrationCoreApi({
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) : golubetsVar_binaryMessenger = binaryMessenger,
       golubetsVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty
           ? '.$messageChannelSuffix'
           : '';
  final BinaryMessenger? golubetsVar_binaryMessenger;

  static const MessageCodec<Object?> golubetsChannelCodec = _GolubetsCodec();

  final String golubetsVar_messageChannelSuffix;

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  Future<void> noop() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.noop$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the passed object, to test serialization and deserialization.
  Future<AllTypes> echoAllTypes(AllTypes everything) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAllTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypes?)!;
    }
  }

  /// Returns an error, to test error handling.
  Future<Object?> throwError() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.throwError$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  /// Returns an error from a void function, to test error handling.
  Future<void> throwErrorFromVoid() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.throwErrorFromVoid$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns a Flutter error, to test error handling.
  Future<Object?> throwFlutterError() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.throwFlutterError$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  /// Returns passed in int.
  Future<int> echoInt(int anInt) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as int?)!;
    }
  }

  /// Returns passed in double.
  Future<double> echoDouble(double aDouble) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as double?)!;
    }
  }

  /// Returns the passed in boolean.
  Future<bool> echoBool(bool aBool) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoBool$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aBool],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as bool?)!;
    }
  }

  /// Returns the passed in string.
  Future<String> echoString(String aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as String?)!;
    }
  }

  /// Returns the passed in Uint8List.
  Future<Uint8List> echoUint8List(Uint8List aUint8List) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoUint8List$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aUint8List],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Uint8List?)!;
    }
  }

  /// Returns the passed in generic Object.
  Future<Object> echoObject(Object anObject) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoObject$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anObject],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return golubetsVar_replyList[0]!;
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<Object?>> echoList(List<Object?> list) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<Object?>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AnEnum?>> echoEnumList(List<AnEnum?> enumList) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<AnEnum?>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AllNullableTypes?>> echoClassList(
    List<AllNullableTypes?> classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!
          .cast<AllNullableTypes?>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AnEnum>> echoNonNullEnumList(List<AnEnum> enumList) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNonNullEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<AnEnum>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AllNullableTypes>> echoNonNullClassList(
    List<AllNullableTypes> classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNonNullClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!
          .cast<AllNullableTypes>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<Object?, Object?>> echoMap(Map<Object?, Object?> map) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[map],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<Object?, Object?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<String?, String?>> echoStringMap(
    Map<String?, String?> stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, String?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int?, int?>> echoIntMap(Map<int?, int?> intMap) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int?, int?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<AnEnum?, AnEnum?>> echoEnumMap(
    Map<AnEnum?, AnEnum?> enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<AnEnum?, AnEnum?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int?, AllNullableTypes?>> echoClassMap(
    Map<int?, AllNullableTypes?> classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int?, AllNullableTypes?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<String, String>> echoNonNullStringMap(
    Map<String, String> stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNonNullStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, String>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int, int>> echoNonNullIntMap(Map<int, int> intMap) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNonNullIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int, int>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<AnEnum, AnEnum>> echoNonNullEnumMap(
    Map<AnEnum, AnEnum> enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNonNullEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<AnEnum, AnEnum>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int, AllNullableTypes>> echoNonNullClassMap(
    Map<int, AllNullableTypes> classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNonNullClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int, AllNullableTypes>();
    }
  }

  /// Returns the passed class to test nested class serialization and deserialization.
  Future<AllClassesWrapper> echoClassWrapper(AllClassesWrapper wrapper) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoClassWrapper$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[wrapper],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllClassesWrapper?)!;
    }
  }

  /// Returns the passed enum to test serialization and deserialization.
  Future<AnEnum> echoEnum(AnEnum anEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AnEnum?)!;
    }
  }

  /// Returns the passed enum to test serialization and deserialization.
  Future<AnotherEnum> echoAnotherEnum(AnotherEnum anotherEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAnotherEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anotherEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AnotherEnum?)!;
    }
  }

  /// Returns the default string.
  Future<String> echoNamedDefaultString({String aString = 'default'}) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNamedDefaultString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as String?)!;
    }
  }

  /// Returns passed in double.
  Future<double> echoOptionalDefaultDouble([double aDouble = 3.14]) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoOptionalDefaultDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as double?)!;
    }
  }

  /// Returns a new AllTypesWithDefaults instance with all default values.
  Future<AllTypesWithDefaults> createAllTypesWithDefaults() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.createAllTypesWithDefaults$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypesWithDefaults?)!;
    }
  }

  /// Returns an AllTypesWithDefaults instance, verifying default values work in cross-platform communication.
  Future<AllTypesWithDefaults> echoAllTypesWithDefaults(
    AllTypesWithDefaults allTypes,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAllTypesWithDefaults$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[allTypes],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypesWithDefaults?)!;
    }
  }

  /// Returns passed in int.
  Future<int> echoRequiredInt({required int anInt}) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoRequiredInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as int?)!;
    }
  }

  /// Returns the passed object, to test serialization and deserialization.
  Future<AllNullableTypes?> echoAllNullableTypes(
    AllNullableTypes? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAllNullableTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypes?);
    }
  }

  /// Returns the passed object, to test serialization and deserialization.
  Future<AllNullableTypesWithoutRecursion?>
  echoAllNullableTypesWithoutRecursion(
    AllNullableTypesWithoutRecursion? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAllNullableTypesWithoutRecursion$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypesWithoutRecursion?);
    }
  }

  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  Future<String?> extractNestedNullableString(AllClassesWrapper wrapper) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.extractNestedNullableString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[wrapper],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as String?);
    }
  }

  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  Future<AllClassesWrapper> createNestedNullableString(
    String? nullableString,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.createNestedNullableString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[nullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllClassesWrapper?)!;
    }
  }

  /// Returns passed in arguments of multiple types.
  Future<AllNullableTypes> sendMultipleNullableTypes(
    bool? aNullableBool,
    int? aNullableInt,
    String? aNullableString,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.sendMultipleNullableTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableBool, aNullableInt, aNullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypes?)!;
    }
  }

  /// Returns passed in arguments of multiple types.
  Future<AllNullableTypesWithoutRecursion>
  sendMultipleNullableTypesWithoutRecursion(
    bool? aNullableBool,
    int? aNullableInt,
    String? aNullableString,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.sendMultipleNullableTypesWithoutRecursion$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableBool, aNullableInt, aNullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypesWithoutRecursion?)!;
    }
  }

  /// Returns passed in int.
  Future<int?> echoNullableInt(int? aNullableInt) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as int?);
    }
  }

  /// Returns passed in double.
  Future<double?> echoNullableDouble(double? aNullableDouble) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as double?);
    }
  }

  /// Returns the passed in boolean.
  Future<bool?> echoNullableBool(bool? aNullableBool) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableBool$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableBool],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as bool?);
    }
  }

  /// Returns the passed in string.
  Future<String?> echoNullableString(String? aNullableString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as String?);
    }
  }

  /// Returns the passed in Uint8List.
  Future<Uint8List?> echoNullableUint8List(
    Uint8List? aNullableUint8List,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableUint8List$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableUint8List],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Uint8List?);
    }
  }

  /// Returns the passed in generic Object.
  Future<Object?> echoNullableObject(Object? aNullableObject) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableObject$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableObject],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<Object?>?> echoNullableList(List<Object?>? aNullableList) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<Object?>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AnEnum?>?> echoNullableEnumList(List<AnEnum?>? enumList) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<AnEnum?>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AllNullableTypes?>?> echoNullableClassList(
    List<AllNullableTypes?>? classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)
          ?.cast<AllNullableTypes?>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AnEnum>?> echoNullableNonNullEnumList(
    List<AnEnum>? enumList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableNonNullEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<AnEnum>();
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<AllNullableTypes>?> echoNullableNonNullClassList(
    List<AllNullableTypes>? classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableNonNullClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)
          ?.cast<AllNullableTypes>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<Object?, Object?>?> echoNullableMap(
    Map<Object?, Object?>? map,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[map],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<Object?, Object?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<String?, String?>?> echoNullableStringMap(
    Map<String?, String?>? stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String?, String?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int?, int?>?> echoNullableIntMap(Map<int?, int?>? intMap) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int?, int?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<AnEnum?, AnEnum?>?> echoNullableEnumMap(
    Map<AnEnum?, AnEnum?>? enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<AnEnum?, AnEnum?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int?, AllNullableTypes?>?> echoNullableClassMap(
    Map<int?, AllNullableTypes?>? classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int?, AllNullableTypes?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<String, String>?> echoNullableNonNullStringMap(
    Map<String, String>? stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableNonNullStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String, String>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int, int>?> echoNullableNonNullIntMap(
    Map<int, int>? intMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableNonNullIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int, int>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<AnEnum, AnEnum>?> echoNullableNonNullEnumMap(
    Map<AnEnum, AnEnum>? enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableNonNullEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<AnEnum, AnEnum>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<int, AllNullableTypes>?> echoNullableNonNullClassMap(
    Map<int, AllNullableTypes>? classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableNonNullClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int, AllNullableTypes>();
    }
  }

  Future<AnEnum?> echoNullableEnum(AnEnum? anEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNullableEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AnEnum?);
    }
  }

  Future<AnotherEnum?> echoAnotherNullableEnum(AnotherEnum? anotherEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAnotherNullableEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anotherEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AnotherEnum?);
    }
  }

  /// Returns passed in int.
  Future<int?> echoOptionalNullableInt([int? aNullableInt]) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoOptionalNullableInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as int?);
    }
  }

  /// Returns the passed in string.
  Future<String?> echoNamedNullableString({String? aNullableString}) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoNamedNullableString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as String?);
    }
  }

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  Future<void> noopAsync() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.noopAsync$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns passed in int asynchronously.
  Future<int> echoAsyncInt(int anInt) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as int?)!;
    }
  }

  /// Returns passed in double asynchronously.
  Future<double> echoAsyncDouble(double aDouble) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as double?)!;
    }
  }

  /// Returns the passed in boolean asynchronously.
  Future<bool> echoAsyncBool(bool aBool) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncBool$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aBool],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as bool?)!;
    }
  }

  /// Returns the passed string asynchronously.
  Future<String> echoAsyncString(String aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as String?)!;
    }
  }

  /// Returns the passed in Uint8List asynchronously.
  Future<Uint8List> echoAsyncUint8List(Uint8List aUint8List) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncUint8List$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aUint8List],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Uint8List?)!;
    }
  }

  /// Returns the passed in generic Object asynchronously.
  Future<Object> echoAsyncObject(Object anObject) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncObject$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anObject],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return golubetsVar_replyList[0]!;
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<Object?>> echoAsyncList(List<Object?> list) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<Object?>();
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<AnEnum?>> echoAsyncEnumList(List<AnEnum?> enumList) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<AnEnum?>();
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<AllNullableTypes?>> echoAsyncClassList(
    List<AllNullableTypes?> classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!
          .cast<AllNullableTypes?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<Object?, Object?>> echoAsyncMap(Map<Object?, Object?> map) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[map],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<Object?, Object?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<String?, String?>> echoAsyncStringMap(
    Map<String?, String?> stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, String?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<int?, int?>> echoAsyncIntMap(Map<int?, int?> intMap) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int?, int?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<AnEnum?, AnEnum?>> echoAsyncEnumMap(
    Map<AnEnum?, AnEnum?> enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<AnEnum?, AnEnum?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<int?, AllNullableTypes?>> echoAsyncClassMap(
    Map<int?, AllNullableTypes?> classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int?, AllNullableTypes?>();
    }
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  Future<AnEnum> echoAsyncEnum(AnEnum anEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AnEnum?)!;
    }
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  Future<AnotherEnum> echoAnotherAsyncEnum(AnotherEnum anotherEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAnotherAsyncEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anotherEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AnotherEnum?)!;
    }
  }

  /// Responds with an error from an async function returning a value.
  Future<Object?> throwAsyncError() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.throwAsyncError$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  /// Responds with an error from an async void function.
  Future<void> throwAsyncErrorFromVoid() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.throwAsyncErrorFromVoid$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Responds with a Flutter error from an async function returning a value.
  Future<Object?> throwAsyncFlutterError() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.throwAsyncFlutterError$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  /// Returns the passed object, to test async serialization and deserialization.
  Future<AllTypes> echoAsyncAllTypes(AllTypes everything) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncAllTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypes?)!;
    }
  }

  /// Returns the passed object, to test async serialization and deserialization using `await`-style
  /// and Swift does not throw an exception.
  Future<AllTypes> echoModernAsyncAllTypes(AllTypes everything) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoModernAsyncAllTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypes?)!;
    }
  }

  /// Returns the passed object, to test async serialization and deserialization using `await`-style
  /// and Swift can throw an exception.
  Future<AllTypes> echoModernAsyncAllTypesAndNotThrow(
    AllTypes everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoModernAsyncAllTypesAndNotThrow$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypes?)!;
    }
  }

  /// Returns the passed object, to test async serialization and deserialization using `await`-style
  /// and throws an exception.
  Future<AllTypes> echoModernAsyncAllTypesAndThrow(AllTypes everything) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoModernAsyncAllTypesAndThrow$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypes?)!;
    }
  }

  /// Returns the passed object, to test serialization and deserialization.
  Future<AllNullableTypes?> echoAsyncNullableAllNullableTypes(
    AllNullableTypes? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableAllNullableTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypes?);
    }
  }

  /// Returns the passed object, to test async serialization and deserialization using `await`-style
  /// and Swift does not throw an exception.
  Future<AllNullableTypes?> echoModernAsyncNullableAllNullableTypes(
    AllNullableTypes? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoModernAsyncNullableAllNullableTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypes?);
    }
  }

  /// Returns the passed object, to test serialization and deserialization.
  Future<AllNullableTypesWithoutRecursion?>
  echoAsyncNullableAllNullableTypesWithoutRecursion(
    AllNullableTypesWithoutRecursion? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableAllNullableTypesWithoutRecursion$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypesWithoutRecursion?);
    }
  }

  /// Returns passed in int asynchronously.
  Future<int?> echoAsyncNullableInt(int? anInt) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as int?);
    }
  }

  /// Returns passed in double asynchronously.
  Future<double?> echoAsyncNullableDouble(double? aDouble) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as double?);
    }
  }

  /// Returns the passed in boolean asynchronously.
  Future<bool?> echoAsyncNullableBool(bool? aBool) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableBool$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aBool],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as bool?);
    }
  }

  /// Returns the passed string asynchronously.
  Future<String?> echoAsyncNullableString(String? aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as String?);
    }
  }

  /// Returns the passed in Uint8List asynchronously.
  Future<Uint8List?> echoAsyncNullableUint8List(Uint8List? aUint8List) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableUint8List$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aUint8List],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Uint8List?);
    }
  }

  /// Returns the passed in generic Object asynchronously.
  Future<Object?> echoAsyncNullableObject(Object? anObject) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableObject$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anObject],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<Object?>?> echoAsyncNullableList(List<Object?>? list) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<Object?>();
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<AnEnum?>?> echoAsyncNullableEnumList(
    List<AnEnum?>? enumList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<AnEnum?>();
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<AllNullableTypes?>?> echoAsyncNullableClassList(
    List<AllNullableTypes?>? classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)
          ?.cast<AllNullableTypes?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<Object?, Object?>?> echoAsyncNullableMap(
    Map<Object?, Object?>? map,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[map],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<Object?, Object?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<String?, String?>?> echoAsyncNullableStringMap(
    Map<String?, String?>? stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String?, String?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<int?, int?>?> echoAsyncNullableIntMap(
    Map<int?, int?>? intMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int?, int?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<AnEnum?, AnEnum?>?> echoAsyncNullableEnumMap(
    Map<AnEnum?, AnEnum?>? enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<AnEnum?, AnEnum?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<int?, AllNullableTypes?>?> echoAsyncNullableClassMap(
    Map<int?, AllNullableTypes?>? classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int?, AllNullableTypes?>();
    }
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  Future<AnEnum?> echoAsyncNullableEnum(AnEnum? anEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAsyncNullableEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AnEnum?);
    }
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  Future<AnotherEnum?> echoAnotherAsyncNullableEnum(
    AnotherEnum? anotherEnum,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.echoAnotherAsyncNullableEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anotherEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AnotherEnum?);
    }
  }

  /// Returns true if the handler is run on a main thread, which should be
  /// true since there is no TaskQueue annotation.
  Future<bool> defaultIsMainThread() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.defaultIsMainThread$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as bool?)!;
    }
  }

  /// Returns true if the handler is run on a non-main thread, which should be
  /// true for any platform with TaskQueue support.
  Future<bool> taskQueueIsBackgroundThread() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.taskQueueIsBackgroundThread$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as bool?)!;
    }
  }

  Future<void> callFlutterNoop() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterNoop$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<Object?> callFlutterThrowError() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterThrowError$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return golubetsVar_replyList[0];
    }
  }

  Future<void> callFlutterThrowErrorFromVoid() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterThrowErrorFromVoid$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<AllTypes> callFlutterEchoAllTypes(AllTypes everything) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoAllTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllTypes?)!;
    }
  }

  Future<AllNullableTypes?> callFlutterEchoAllNullableTypes(
    AllNullableTypes? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoAllNullableTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypes?);
    }
  }

  Future<AllNullableTypes> callFlutterSendMultipleNullableTypes(
    bool? aNullableBool,
    int? aNullableInt,
    String? aNullableString,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterSendMultipleNullableTypes$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableBool, aNullableInt, aNullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypes?)!;
    }
  }

  Future<AllNullableTypesWithoutRecursion?>
  callFlutterEchoAllNullableTypesWithoutRecursion(
    AllNullableTypesWithoutRecursion? everything,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoAllNullableTypesWithoutRecursion$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[everything],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypesWithoutRecursion?);
    }
  }

  Future<AllNullableTypesWithoutRecursion>
  callFlutterSendMultipleNullableTypesWithoutRecursion(
    bool? aNullableBool,
    int? aNullableInt,
    String? aNullableString,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterSendMultipleNullableTypesWithoutRecursion$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aNullableBool, aNullableInt, aNullableString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AllNullableTypesWithoutRecursion?)!;
    }
  }

  Future<bool> callFlutterEchoBool(bool aBool) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoBool$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aBool],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as bool?)!;
    }
  }

  Future<int> callFlutterEchoInt(int anInt) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as int?)!;
    }
  }

  Future<double> callFlutterEchoDouble(double aDouble) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as double?)!;
    }
  }

  Future<String> callFlutterEchoString(String aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as String?)!;
    }
  }

  Future<Uint8List> callFlutterEchoUint8List(Uint8List list) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoUint8List$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Uint8List?)!;
    }
  }

  Future<List<Object?>> callFlutterEchoList(List<Object?> list) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<Object?>();
    }
  }

  Future<List<AnEnum?>> callFlutterEchoEnumList(List<AnEnum?> enumList) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<AnEnum?>();
    }
  }

  Future<List<AllNullableTypes?>> callFlutterEchoClassList(
    List<AllNullableTypes?> classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!
          .cast<AllNullableTypes?>();
    }
  }

  Future<List<AnEnum>> callFlutterEchoNonNullEnumList(
    List<AnEnum> enumList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNonNullEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!.cast<AnEnum>();
    }
  }

  Future<List<AllNullableTypes>> callFlutterEchoNonNullClassList(
    List<AllNullableTypes> classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNonNullClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)!
          .cast<AllNullableTypes>();
    }
  }

  Future<Map<Object?, Object?>> callFlutterEchoMap(
    Map<Object?, Object?> map,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[map],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<Object?, Object?>();
    }
  }

  Future<Map<String?, String?>> callFlutterEchoStringMap(
    Map<String?, String?> stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, String?>();
    }
  }

  Future<Map<int?, int?>> callFlutterEchoIntMap(Map<int?, int?> intMap) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int?, int?>();
    }
  }

  Future<Map<AnEnum?, AnEnum?>> callFlutterEchoEnumMap(
    Map<AnEnum?, AnEnum?> enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<AnEnum?, AnEnum?>();
    }
  }

  Future<Map<int?, AllNullableTypes?>> callFlutterEchoClassMap(
    Map<int?, AllNullableTypes?> classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int?, AllNullableTypes?>();
    }
  }

  Future<Map<String, String>> callFlutterEchoNonNullStringMap(
    Map<String, String> stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNonNullStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, String>();
    }
  }

  Future<Map<int, int>> callFlutterEchoNonNullIntMap(
    Map<int, int> intMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNonNullIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int, int>();
    }
  }

  Future<Map<AnEnum, AnEnum>> callFlutterEchoNonNullEnumMap(
    Map<AnEnum, AnEnum> enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNonNullEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<AnEnum, AnEnum>();
    }
  }

  Future<Map<int, AllNullableTypes>> callFlutterEchoNonNullClassMap(
    Map<int, AllNullableTypes> classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNonNullClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<int, AllNullableTypes>();
    }
  }

  Future<AnEnum> callFlutterEchoEnum(AnEnum anEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AnEnum?)!;
    }
  }

  Future<AnotherEnum> callFlutterEchoAnotherEnum(
    AnotherEnum anotherEnum,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoAnotherEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anotherEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as AnotherEnum?)!;
    }
  }

  Future<bool?> callFlutterEchoNullableBool(bool? aBool) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableBool$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aBool],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as bool?);
    }
  }

  Future<int?> callFlutterEchoNullableInt(int? anInt) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableInt$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anInt],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as int?);
    }
  }

  Future<double?> callFlutterEchoNullableDouble(double? aDouble) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableDouble$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aDouble],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as double?);
    }
  }

  Future<String?> callFlutterEchoNullableString(String? aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as String?);
    }
  }

  Future<Uint8List?> callFlutterEchoNullableUint8List(Uint8List? list) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableUint8List$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Uint8List?);
    }
  }

  Future<List<Object?>?> callFlutterEchoNullableList(
    List<Object?>? list,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[list],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<Object?>();
    }
  }

  Future<List<AnEnum?>?> callFlutterEchoNullableEnumList(
    List<AnEnum?>? enumList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<AnEnum?>();
    }
  }

  Future<List<AllNullableTypes?>?> callFlutterEchoNullableClassList(
    List<AllNullableTypes?>? classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)
          ?.cast<AllNullableTypes?>();
    }
  }

  Future<List<AnEnum>?> callFlutterEchoNullableNonNullEnumList(
    List<AnEnum>? enumList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableNonNullEnumList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)?.cast<AnEnum>();
    }
  }

  Future<List<AllNullableTypes>?> callFlutterEchoNullableNonNullClassList(
    List<AllNullableTypes>? classList,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableNonNullClassList$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classList],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as List<Object?>?)
          ?.cast<AllNullableTypes>();
    }
  }

  Future<Map<Object?, Object?>?> callFlutterEchoNullableMap(
    Map<Object?, Object?>? map,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[map],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<Object?, Object?>();
    }
  }

  Future<Map<String?, String?>?> callFlutterEchoNullableStringMap(
    Map<String?, String?>? stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String?, String?>();
    }
  }

  Future<Map<int?, int?>?> callFlutterEchoNullableIntMap(
    Map<int?, int?>? intMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int?, int?>();
    }
  }

  Future<Map<AnEnum?, AnEnum?>?> callFlutterEchoNullableEnumMap(
    Map<AnEnum?, AnEnum?>? enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<AnEnum?, AnEnum?>();
    }
  }

  Future<Map<int?, AllNullableTypes?>?> callFlutterEchoNullableClassMap(
    Map<int?, AllNullableTypes?>? classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int?, AllNullableTypes?>();
    }
  }

  Future<Map<String, String>?> callFlutterEchoNullableNonNullStringMap(
    Map<String, String>? stringMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableNonNullStringMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[stringMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String, String>();
    }
  }

  Future<Map<int, int>?> callFlutterEchoNullableNonNullIntMap(
    Map<int, int>? intMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableNonNullIntMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[intMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int, int>();
    }
  }

  Future<Map<AnEnum, AnEnum>?> callFlutterEchoNullableNonNullEnumMap(
    Map<AnEnum, AnEnum>? enumMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableNonNullEnumMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[enumMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<AnEnum, AnEnum>();
    }
  }

  Future<Map<int, AllNullableTypes>?> callFlutterEchoNullableNonNullClassMap(
    Map<int, AllNullableTypes>? classMap,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableNonNullClassMap$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[classMap],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<int, AllNullableTypes>();
    }
  }

  Future<AnEnum?> callFlutterEchoNullableEnum(AnEnum? anEnum) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AnEnum?);
    }
  }

  Future<AnotherEnum?> callFlutterEchoAnotherNullableEnum(
    AnotherEnum? anotherEnum,
  ) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterEchoAnotherNullableEnum$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[anotherEnum],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return (golubetsVar_replyList[0] as AnotherEnum?);
    }
  }

  Future<String> callFlutterSmallApiEchoString(String aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostIntegrationCoreApi.callFlutterSmallApiEchoString$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as String?)!;
    }
  }
}

/// The core interface that the Dart platform_test code implements for host
/// integration tests to call into.
abstract class FlutterIntegrationCoreApi {
  static const MessageCodec<Object?> golubetsChannelCodec = _GolubetsCodec();

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  void noop();

  /// Responds with an error from an async function returning a value.
  Object? throwError();

  /// Responds with an error from an async void function.
  void throwErrorFromVoid();

  /// Returns the passed object, to test serialization and deserialization.
  AllTypes echoAllTypes(AllTypes everything);

  /// Returns the passed object, to test serialization and deserialization.
  AllNullableTypes? echoAllNullableTypes(AllNullableTypes? everything);

  /// Returns passed in arguments of multiple types.
  ///
  /// Tests multiple-arity FlutterApi handling.
  AllNullableTypes sendMultipleNullableTypes(
    bool? aNullableBool,
    int? aNullableInt,
    String? aNullableString,
  );

  /// Returns the passed object, to test serialization and deserialization.
  AllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    AllNullableTypesWithoutRecursion? everything,
  );

  /// Returns passed in arguments of multiple types.
  ///
  /// Tests multiple-arity FlutterApi handling.
  AllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    bool? aNullableBool,
    int? aNullableInt,
    String? aNullableString,
  );

  /// Returns the passed boolean, to test serialization and deserialization.
  bool echoBool(bool aBool);

  /// Returns the passed int, to test serialization and deserialization.
  int echoInt(int anInt);

  /// Returns the passed double, to test serialization and deserialization.
  double echoDouble(double aDouble);

  /// Returns the passed string, to test serialization and deserialization.
  String echoString(String aString);

  /// Returns the passed byte list, to test serialization and deserialization.
  Uint8List echoUint8List(Uint8List list);

  /// Returns the passed list, to test serialization and deserialization.
  List<Object?> echoList(List<Object?> list);

  /// Returns the passed list, to test serialization and deserialization.
  List<AnEnum?> echoEnumList(List<AnEnum?> enumList);

  /// Returns the passed list, to test serialization and deserialization.
  List<AllNullableTypes?> echoClassList(List<AllNullableTypes?> classList);

  /// Returns the passed list, to test serialization and deserialization.
  List<AnEnum> echoNonNullEnumList(List<AnEnum> enumList);

  /// Returns the passed list, to test serialization and deserialization.
  List<AllNullableTypes> echoNonNullClassList(List<AllNullableTypes> classList);

  /// Returns the passed map, to test serialization and deserialization.
  Map<Object?, Object?> echoMap(Map<Object?, Object?> map);

  /// Returns the passed map, to test serialization and deserialization.
  Map<String?, String?> echoStringMap(Map<String?, String?> stringMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<int?, int?> echoIntMap(Map<int?, int?> intMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<AnEnum?, AnEnum?> echoEnumMap(Map<AnEnum?, AnEnum?> enumMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<int?, AllNullableTypes?> echoClassMap(
    Map<int?, AllNullableTypes?> classMap,
  );

  /// Returns the passed map, to test serialization and deserialization.
  Map<String, String> echoNonNullStringMap(Map<String, String> stringMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<int, int> echoNonNullIntMap(Map<int, int> intMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<AnEnum, AnEnum> echoNonNullEnumMap(Map<AnEnum, AnEnum> enumMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<int, AllNullableTypes> echoNonNullClassMap(
    Map<int, AllNullableTypes> classMap,
  );

  /// Returns the passed enum to test serialization and deserialization.
  AnEnum echoEnum(AnEnum anEnum);

  /// Returns the passed enum to test serialization and deserialization.
  AnotherEnum echoAnotherEnum(AnotherEnum anotherEnum);

  /// Returns the passed boolean, to test serialization and deserialization.
  bool? echoNullableBool(bool? aBool);

  /// Returns the passed int, to test serialization and deserialization.
  int? echoNullableInt(int? anInt);

  /// Returns the passed double, to test serialization and deserialization.
  double? echoNullableDouble(double? aDouble);

  /// Returns the passed string, to test serialization and deserialization.
  String? echoNullableString(String? aString);

  /// Returns the passed byte list, to test serialization and deserialization.
  Uint8List? echoNullableUint8List(Uint8List? list);

  /// Returns the passed list, to test serialization and deserialization.
  List<Object?>? echoNullableList(List<Object?>? list);

  /// Returns the passed list, to test serialization and deserialization.
  List<AnEnum?>? echoNullableEnumList(List<AnEnum?>? enumList);

  /// Returns the passed list, to test serialization and deserialization.
  List<AllNullableTypes?>? echoNullableClassList(
    List<AllNullableTypes?>? classList,
  );

  /// Returns the passed list, to test serialization and deserialization.
  List<AnEnum>? echoNullableNonNullEnumList(List<AnEnum>? enumList);

  /// Returns the passed list, to test serialization and deserialization.
  List<AllNullableTypes>? echoNullableNonNullClassList(
    List<AllNullableTypes>? classList,
  );

  /// Returns the passed map, to test serialization and deserialization.
  Map<Object?, Object?>? echoNullableMap(Map<Object?, Object?>? map);

  /// Returns the passed map, to test serialization and deserialization.
  Map<String?, String?>? echoNullableStringMap(
    Map<String?, String?>? stringMap,
  );

  /// Returns the passed map, to test serialization and deserialization.
  Map<int?, int?>? echoNullableIntMap(Map<int?, int?>? intMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<AnEnum?, AnEnum?>? echoNullableEnumMap(Map<AnEnum?, AnEnum?>? enumMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<int?, AllNullableTypes?>? echoNullableClassMap(
    Map<int?, AllNullableTypes?>? classMap,
  );

  /// Returns the passed map, to test serialization and deserialization.
  Map<String, String>? echoNullableNonNullStringMap(
    Map<String, String>? stringMap,
  );

  /// Returns the passed map, to test serialization and deserialization.
  Map<int, int>? echoNullableNonNullIntMap(Map<int, int>? intMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<AnEnum, AnEnum>? echoNullableNonNullEnumMap(Map<AnEnum, AnEnum>? enumMap);

  /// Returns the passed map, to test serialization and deserialization.
  Map<int, AllNullableTypes>? echoNullableNonNullClassMap(
    Map<int, AllNullableTypes>? classMap,
  );

  /// Returns the passed enum to test serialization and deserialization.
  AnEnum? echoNullableEnum(AnEnum? anEnum);

  /// Returns the passed enum to test serialization and deserialization.
  AnotherEnum? echoAnotherNullableEnum(AnotherEnum? anotherEnum);

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  Future<void> noopAsync();

  /// Returns the passed in generic Object asynchronously.
  Future<String> echoAsyncString(String aString);

  static void setUp(
    FlutterIntegrationCoreApi? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix = messageChannelSuffix.isNotEmpty
        ? '.$messageChannelSuffix'
        : '';
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.noop$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          try {
            api.noop();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.throwError$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          try {
            final Object? output = api.throwError();
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.throwErrorFromVoid$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          try {
            api.throwErrorFromVoid();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllTypes$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllTypes was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AllTypes? arg_everything = (args[0] as AllTypes?);
          assert(
            arg_everything != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllTypes was null, expected non-null AllTypes.',
          );
          try {
            final AllTypes output = api.echoAllTypes(arg_everything!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllNullableTypes$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllNullableTypes was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AllNullableTypes? arg_everything =
              (args[0] as AllNullableTypes?);
          try {
            final AllNullableTypes? output = api.echoAllNullableTypes(
              arg_everything,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.sendMultipleNullableTypes$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.sendMultipleNullableTypes was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final bool? arg_aNullableBool = (args[0] as bool?);
          final int? arg_aNullableInt = (args[1] as int?);
          final String? arg_aNullableString = (args[2] as String?);
          try {
            final AllNullableTypes output = api.sendMultipleNullableTypes(
              arg_aNullableBool,
              arg_aNullableInt,
              arg_aNullableString,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllNullableTypesWithoutRecursion$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAllNullableTypesWithoutRecursion was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AllNullableTypesWithoutRecursion? arg_everything =
              (args[0] as AllNullableTypesWithoutRecursion?);
          try {
            final AllNullableTypesWithoutRecursion? output = api
                .echoAllNullableTypesWithoutRecursion(arg_everything);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.sendMultipleNullableTypesWithoutRecursion$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.sendMultipleNullableTypesWithoutRecursion was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final bool? arg_aNullableBool = (args[0] as bool?);
          final int? arg_aNullableInt = (args[1] as int?);
          final String? arg_aNullableString = (args[2] as String?);
          try {
            final AllNullableTypesWithoutRecursion output = api
                .sendMultipleNullableTypesWithoutRecursion(
                  arg_aNullableBool,
                  arg_aNullableInt,
                  arg_aNullableString,
                );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoBool$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoBool was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final bool? arg_aBool = (args[0] as bool?);
          assert(
            arg_aBool != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoBool was null, expected non-null bool.',
          );
          try {
            final bool output = api.echoBool(arg_aBool!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoInt$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoInt was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_anInt = (args[0] as int?);
          assert(
            arg_anInt != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoInt was null, expected non-null int.',
          );
          try {
            final int output = api.echoInt(arg_anInt!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoDouble$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoDouble was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final double? arg_aDouble = (args[0] as double?);
          assert(
            arg_aDouble != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoDouble was null, expected non-null double.',
          );
          try {
            final double output = api.echoDouble(arg_aDouble!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoString$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_aString = (args[0] as String?);
          assert(
            arg_aString != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoString was null, expected non-null String.',
          );
          try {
            final String output = api.echoString(arg_aString!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoUint8List$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoUint8List was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Uint8List? arg_list = (args[0] as Uint8List?);
          assert(
            arg_list != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoUint8List was null, expected non-null Uint8List.',
          );
          try {
            final Uint8List output = api.echoUint8List(arg_list!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<Object?>? arg_list = (args[0] as List<Object?>?)
              ?.cast<Object?>();
          assert(
            arg_list != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoList was null, expected non-null List<Object?>.',
          );
          try {
            final List<Object?> output = api.echoList(arg_list!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnumList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnumList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AnEnum?>? arg_enumList = (args[0] as List<Object?>?)
              ?.cast<AnEnum?>();
          assert(
            arg_enumList != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnumList was null, expected non-null List<AnEnum?>.',
          );
          try {
            final List<AnEnum?> output = api.echoEnumList(arg_enumList!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoClassList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoClassList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AllNullableTypes?>? arg_classList =
              (args[0] as List<Object?>?)?.cast<AllNullableTypes?>();
          assert(
            arg_classList != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoClassList was null, expected non-null List<AllNullableTypes?>.',
          );
          try {
            final List<AllNullableTypes?> output = api.echoClassList(
              arg_classList!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullEnumList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullEnumList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AnEnum>? arg_enumList = (args[0] as List<Object?>?)
              ?.cast<AnEnum>();
          assert(
            arg_enumList != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullEnumList was null, expected non-null List<AnEnum>.',
          );
          try {
            final List<AnEnum> output = api.echoNonNullEnumList(arg_enumList!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullClassList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullClassList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AllNullableTypes>? arg_classList =
              (args[0] as List<Object?>?)?.cast<AllNullableTypes>();
          assert(
            arg_classList != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullClassList was null, expected non-null List<AllNullableTypes>.',
          );
          try {
            final List<AllNullableTypes> output = api.echoNonNullClassList(
              arg_classList!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<Object?, Object?>? arg_map =
              (args[0] as Map<Object?, Object?>?)?.cast<Object?, Object?>();
          assert(
            arg_map != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoMap was null, expected non-null Map<Object?, Object?>.',
          );
          try {
            final Map<Object?, Object?> output = api.echoMap(arg_map!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoStringMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoStringMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<String?, String?>? arg_stringMap =
              (args[0] as Map<Object?, Object?>?)?.cast<String?, String?>();
          assert(
            arg_stringMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoStringMap was null, expected non-null Map<String?, String?>.',
          );
          try {
            final Map<String?, String?> output = api.echoStringMap(
              arg_stringMap!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoIntMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoIntMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int?, int?>? arg_intMap =
              (args[0] as Map<Object?, Object?>?)?.cast<int?, int?>();
          assert(
            arg_intMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoIntMap was null, expected non-null Map<int?, int?>.',
          );
          try {
            final Map<int?, int?> output = api.echoIntMap(arg_intMap!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnumMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnumMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<AnEnum?, AnEnum?>? arg_enumMap =
              (args[0] as Map<Object?, Object?>?)?.cast<AnEnum?, AnEnum?>();
          assert(
            arg_enumMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnumMap was null, expected non-null Map<AnEnum?, AnEnum?>.',
          );
          try {
            final Map<AnEnum?, AnEnum?> output = api.echoEnumMap(arg_enumMap!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoClassMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoClassMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int?, AllNullableTypes?>? arg_classMap =
              (args[0] as Map<Object?, Object?>?)
                  ?.cast<int?, AllNullableTypes?>();
          assert(
            arg_classMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoClassMap was null, expected non-null Map<int?, AllNullableTypes?>.',
          );
          try {
            final Map<int?, AllNullableTypes?> output = api.echoClassMap(
              arg_classMap!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullStringMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullStringMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<String, String>? arg_stringMap =
              (args[0] as Map<Object?, Object?>?)?.cast<String, String>();
          assert(
            arg_stringMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullStringMap was null, expected non-null Map<String, String>.',
          );
          try {
            final Map<String, String> output = api.echoNonNullStringMap(
              arg_stringMap!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullIntMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullIntMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int, int>? arg_intMap = (args[0] as Map<Object?, Object?>?)
              ?.cast<int, int>();
          assert(
            arg_intMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullIntMap was null, expected non-null Map<int, int>.',
          );
          try {
            final Map<int, int> output = api.echoNonNullIntMap(arg_intMap!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullEnumMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullEnumMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<AnEnum, AnEnum>? arg_enumMap =
              (args[0] as Map<Object?, Object?>?)?.cast<AnEnum, AnEnum>();
          assert(
            arg_enumMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullEnumMap was null, expected non-null Map<AnEnum, AnEnum>.',
          );
          try {
            final Map<AnEnum, AnEnum> output = api.echoNonNullEnumMap(
              arg_enumMap!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullClassMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullClassMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int, AllNullableTypes>? arg_classMap =
              (args[0] as Map<Object?, Object?>?)
                  ?.cast<int, AllNullableTypes>();
          assert(
            arg_classMap != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNonNullClassMap was null, expected non-null Map<int, AllNullableTypes>.',
          );
          try {
            final Map<int, AllNullableTypes> output = api.echoNonNullClassMap(
              arg_classMap!,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnum$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnum was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AnEnum? arg_anEnum = (args[0] as AnEnum?);
          assert(
            arg_anEnum != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoEnum was null, expected non-null AnEnum.',
          );
          try {
            final AnEnum output = api.echoEnum(arg_anEnum!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAnotherEnum$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAnotherEnum was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AnotherEnum? arg_anotherEnum = (args[0] as AnotherEnum?);
          assert(
            arg_anotherEnum != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAnotherEnum was null, expected non-null AnotherEnum.',
          );
          try {
            final AnotherEnum output = api.echoAnotherEnum(arg_anotherEnum!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableBool$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableBool was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final bool? arg_aBool = (args[0] as bool?);
          try {
            final bool? output = api.echoNullableBool(arg_aBool);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableInt$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableInt was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_anInt = (args[0] as int?);
          try {
            final int? output = api.echoNullableInt(arg_anInt);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableDouble$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableDouble was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final double? arg_aDouble = (args[0] as double?);
          try {
            final double? output = api.echoNullableDouble(arg_aDouble);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableString$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_aString = (args[0] as String?);
          try {
            final String? output = api.echoNullableString(arg_aString);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableUint8List$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableUint8List was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Uint8List? arg_list = (args[0] as Uint8List?);
          try {
            final Uint8List? output = api.echoNullableUint8List(arg_list);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<Object?>? arg_list = (args[0] as List<Object?>?)
              ?.cast<Object?>();
          try {
            final List<Object?>? output = api.echoNullableList(arg_list);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableEnumList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableEnumList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AnEnum?>? arg_enumList = (args[0] as List<Object?>?)
              ?.cast<AnEnum?>();
          try {
            final List<AnEnum?>? output = api.echoNullableEnumList(
              arg_enumList,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableClassList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableClassList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AllNullableTypes?>? arg_classList =
              (args[0] as List<Object?>?)?.cast<AllNullableTypes?>();
          try {
            final List<AllNullableTypes?>? output = api.echoNullableClassList(
              arg_classList,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullEnumList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullEnumList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AnEnum>? arg_enumList = (args[0] as List<Object?>?)
              ?.cast<AnEnum>();
          try {
            final List<AnEnum>? output = api.echoNullableNonNullEnumList(
              arg_enumList,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullClassList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullClassList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final List<AllNullableTypes>? arg_classList =
              (args[0] as List<Object?>?)?.cast<AllNullableTypes>();
          try {
            final List<AllNullableTypes>? output = api
                .echoNullableNonNullClassList(arg_classList);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<Object?, Object?>? arg_map =
              (args[0] as Map<Object?, Object?>?)?.cast<Object?, Object?>();
          try {
            final Map<Object?, Object?>? output = api.echoNullableMap(arg_map);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableStringMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableStringMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<String?, String?>? arg_stringMap =
              (args[0] as Map<Object?, Object?>?)?.cast<String?, String?>();
          try {
            final Map<String?, String?>? output = api.echoNullableStringMap(
              arg_stringMap,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableIntMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableIntMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int?, int?>? arg_intMap =
              (args[0] as Map<Object?, Object?>?)?.cast<int?, int?>();
          try {
            final Map<int?, int?>? output = api.echoNullableIntMap(arg_intMap);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableEnumMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableEnumMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<AnEnum?, AnEnum?>? arg_enumMap =
              (args[0] as Map<Object?, Object?>?)?.cast<AnEnum?, AnEnum?>();
          try {
            final Map<AnEnum?, AnEnum?>? output = api.echoNullableEnumMap(
              arg_enumMap,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableClassMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableClassMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int?, AllNullableTypes?>? arg_classMap =
              (args[0] as Map<Object?, Object?>?)
                  ?.cast<int?, AllNullableTypes?>();
          try {
            final Map<int?, AllNullableTypes?>? output = api
                .echoNullableClassMap(arg_classMap);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullStringMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullStringMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<String, String>? arg_stringMap =
              (args[0] as Map<Object?, Object?>?)?.cast<String, String>();
          try {
            final Map<String, String>? output = api
                .echoNullableNonNullStringMap(arg_stringMap);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullIntMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullIntMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int, int>? arg_intMap = (args[0] as Map<Object?, Object?>?)
              ?.cast<int, int>();
          try {
            final Map<int, int>? output = api.echoNullableNonNullIntMap(
              arg_intMap,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullEnumMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullEnumMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<AnEnum, AnEnum>? arg_enumMap =
              (args[0] as Map<Object?, Object?>?)?.cast<AnEnum, AnEnum>();
          try {
            final Map<AnEnum, AnEnum>? output = api.echoNullableNonNullEnumMap(
              arg_enumMap,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullClassMap$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableNonNullClassMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final Map<int, AllNullableTypes>? arg_classMap =
              (args[0] as Map<Object?, Object?>?)
                  ?.cast<int, AllNullableTypes>();
          try {
            final Map<int, AllNullableTypes>? output = api
                .echoNullableNonNullClassMap(arg_classMap);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableEnum$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoNullableEnum was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AnEnum? arg_anEnum = (args[0] as AnEnum?);
          try {
            final AnEnum? output = api.echoNullableEnum(arg_anEnum);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAnotherNullableEnum$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAnotherNullableEnum was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final AnotherEnum? arg_anotherEnum = (args[0] as AnotherEnum?);
          try {
            final AnotherEnum? output = api.echoAnotherNullableEnum(
              arg_anotherEnum,
            );
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.noopAsync$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          try {
            await api.noopAsync();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAsyncString$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAsyncString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_aString = (args[0] as String?);
          assert(
            arg_aString != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterIntegrationCoreApi.echoAsyncString was null, expected non-null String.',
          );
          try {
            final String output = await api.echoAsyncString(arg_aString!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }
}

/// An API that can be implemented for minimal, compile-only tests.
class HostTrivialApi {
  /// Constructor for [HostTrivialApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  HostTrivialApi({
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) : golubetsVar_binaryMessenger = binaryMessenger,
       golubetsVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty
           ? '.$messageChannelSuffix'
           : '';
  final BinaryMessenger? golubetsVar_binaryMessenger;

  static const MessageCodec<Object?> golubetsChannelCodec = _GolubetsCodec();

  final String golubetsVar_messageChannelSuffix;

  Future<void> noop() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostTrivialApi.noop$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// A simple API implemented in some unit tests.
class HostSmallApi {
  /// Constructor for [HostSmallApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  HostSmallApi({
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) : golubetsVar_binaryMessenger = binaryMessenger,
       golubetsVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty
           ? '.$messageChannelSuffix'
           : '';
  final BinaryMessenger? golubetsVar_binaryMessenger;

  static const MessageCodec<Object?> golubetsChannelCodec = _GolubetsCodec();

  final String golubetsVar_messageChannelSuffix;

  Future<String> echo(String aString) async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostSmallApi.echo$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      <Object?>[aString],
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else if (golubetsVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubetsVar_replyList[0] as String?)!;
    }
  }

  Future<void> voidVoid() async {
    final String golubetsVar_channelName =
        'dev.bayori.golubets.golubets_integration_tests.HostSmallApi.voidVoid$golubetsVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> golubetsVar_channel =
        BasicMessageChannel<Object?>(
          golubetsVar_channelName,
          golubetsChannelCodec,
          binaryMessenger: golubetsVar_binaryMessenger,
        );
    final Future<Object?> golubetsVar_sendFuture = golubetsVar_channel.send(
      null,
    );
    final List<Object?>? golubetsVar_replyList =
        await golubetsVar_sendFuture as List<Object?>?;
    if (golubetsVar_replyList == null) {
      throw _createConnectionError(golubetsVar_channelName);
    } else if (golubetsVar_replyList.length > 1) {
      throw PlatformException(
        code: golubetsVar_replyList[0]! as String,
        message: golubetsVar_replyList[1] as String?,
        details: golubetsVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// A simple API called in some unit tests.
abstract class FlutterSmallApi {
  static const MessageCodec<Object?> golubetsChannelCodec = _GolubetsCodec();

  TestMessage echoWrappedList(TestMessage msg);

  String echoString(String aString);

  static void setUp(
    FlutterSmallApi? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix = messageChannelSuffix.isNotEmpty
        ? '.$messageChannelSuffix'
        : '';
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterSmallApi.echoWrappedList$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterSmallApi.echoWrappedList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final TestMessage? arg_msg = (args[0] as TestMessage?);
          assert(
            arg_msg != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterSmallApi.echoWrappedList was null, expected non-null TestMessage.',
          );
          try {
            final TestMessage output = api.echoWrappedList(arg_msg!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?>
      golubetsVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golubets.golubets_integration_tests.FlutterSmallApi.echoString$messageChannelSuffix',
        golubetsChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (api == null) {
        golubetsVar_channel.setMessageHandler(null);
      } else {
        golubetsVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterSmallApi.echoString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_aString = (args[0] as String?);
          assert(
            arg_aString != null,
            'Argument for dev.bayori.golubets.golubets_integration_tests.FlutterSmallApi.echoString was null, expected non-null String.',
          );
          try {
            final String output = api.echoString(arg_aString!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }
}
